using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;

namespace DoctorsDungeon.Other
{
    internal static class UmlWriter
    {
        /// <summary>
        /// Calls UmlWriter.WriteClass() on all non-abstract classes in this executing assembly.
        /// </summary>
        /// <returns>A list of strings, where each string is a class with its members.</returns>
        public static List<string> GetEntireProject()
        {
            Assembly assembly = Assembly.GetExecutingAssembly();
            List<Type> classes = new List<Type>();
            List<string> outputs = new List<string>();

            try
            {
                Type[] types = assembly.GetTypes();
                IEnumerable<Type> classesInAssembly = types.Where(t => t.IsClass);
                classes.AddRange(classesInAssembly);
            }
            catch (ReflectionTypeLoadException ex)
            {
                Console.WriteLine($"Error loading types from assembly '{assembly.FullName}: {ex.Message}");
            }

            foreach (Type c in classes)
            {
                outputs.Add(GetClass(c, false));
            }

            return outputs;
        }

        /// <summary>
        /// Generates a string containing all members of a given type.
        /// </summary>
        /// <param name="type">The class whose contents will be output.</param>
        /// <param name="writeInherited">Decides if string will include members derived from base classes.</param>
        /// <returns>String containing class name and all its members in Uml format.</returns>
        /// <exception cref="ArgumentNullException"></exception>
        public static string GetClass(Type type, bool writeInherited)
        {
            if (type == null) throw new ArgumentNullException();

            StringBuilder sb = new StringBuilder();
            sb.AppendLine(type.Name);
            sb.Append(GetMembers<FieldInfo>(type, writeInherited, BuildField, type.GetFields));
            sb.Append(GetMembers<PropertyInfo>(type, writeInherited, BuildProperty, type.GetProperties));
            sb.Append("--\n");
            sb.Append(GetMembers<ConstructorInfo>(type, writeInherited, BuildConstructor, type.GetConstructors));
            sb.Append(GetMembers<MethodInfo>(type, writeInherited, BuildMethod, type.GetMethods));

            return sb.ToString();
        }

        /// <summary>
        /// Gets a member collection of type T, and calls the matching BuildMember overload.
        /// </summary>
        /// <typeparam name="T">The type of members to look for.</typeparam>
        /// <param name="type">Reference to the checked class, required to see if the member wasn't derived from a base class.</param>
        /// <param name="writeInherited">Override to enable if you want the base class members included.</param>
        /// <param name="buildMember">The BuildMember overload to call.</param>
        /// <param name="getMembers">The method used to get the members of type T.</param>
        /// <returns>Multilined string containing the UML depiction of the class's T members.</returns>
        private static string GetMembers<T>(Type type, bool writeInherited, Func<T, string> buildMember, Func<BindingFlags, IEnumerable<T>> getMembers)
            where T : MemberInfo
        {
            StringBuilder sb = new StringBuilder();
            foreach (T member in getMembers(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance))
            {
                if (member.DeclaringType == type || writeInherited == true)
                {
                    string item = buildMember(member);
                    if (item != null) sb.AppendLine(item);
                }
            }

            return sb.ToString();
        }

        private static string BuildField(FieldInfo field)
        {
            //Ensure this field isn't autogenerated
            if (field.Name.EndsWith("k__BackingField") == true)
                return null;

            return $"{GetAccessor(field)} {field.Name} : {field.FieldType.Name}";
        }

        private static string BuildProperty(PropertyInfo property)
        {
            StringBuilder sb = new StringBuilder();

            //Obtain accessors for the getter and setter
            char? getAccessor = null;
            char? setAccessor = null;

            if (property.GetGetMethod(nonPublic: true) != null)
                getAccessor = GetAccessor(property, false);

            if (property.GetSetMethod(nonPublic: true) != null)
                setAccessor = GetAccessor(property, true);

            //Arrange accessors to match the required format
            if (getAccessor == setAccessor)
            {
                sb.Append($"{getAccessor}<<get, set>> ");
            }
            else
            {
                sb.Append($"{getAccessor}<<get, {setAccessor}set>> ");
            }

            //Add the rest of the property signature
            sb.Append($"{property.Name} : {property.PropertyType.Name}");

            return sb.ToString();
        }

        private static string BuildConstructor(ConstructorInfo constructor)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append($"{GetAccessor(constructor)} {constructor.DeclaringType.Name}(");

            //Write parameters
            bool firstCase = true;
            foreach (ParameterInfo param in constructor.GetParameters())
            {
                if (firstCase == false) sb.Append(", ");
                sb.Append($"{param.Name} : {param.ParameterType.Name}");
                firstCase = false;
            }

            sb.Append(")");
            return sb.ToString();
        }

        private static string BuildMethod(MethodInfo method)
        {
            if (IsCompilerGenerated(method) == true || method.IsSpecialName == true)
                return null;

            StringBuilder sb = new StringBuilder();

            //Write start of method signature
            sb.Append(GetAccessor(method));
            sb.Append($" {method.Name}(");

            //Write method parameters
            bool moreParams = false;
            foreach (ParameterInfo param in method.GetParameters())
            {
                if (moreParams == true) sb.Append(", ");
                sb.Append($"{param.Name} : {param.ParameterType.Name}");
                moreParams = true;
            }

            //Write end of method signature
            sb.Append($") : {method.ReturnType.Name}");

            return sb.ToString();
        }

        private static char? GetAccessor(FieldInfo fieldInfo)
        {
            return fieldInfo.IsPublic ? '+' : fieldInfo.IsFamily ? '#' : fieldInfo.IsPrivate ? '-' : (char?)null;
        }

        private static char? GetAccessor(PropertyInfo propertyInfo, bool useSetter)
        {
            var methodInfo = useSetter ? propertyInfo.GetSetMethod(true) : propertyInfo.GetGetMethod(true);
            return methodInfo?.IsPublic == true ? '+' : methodInfo?.IsFamily == true ? '#' : methodInfo?.IsPrivate == true ? '-' : (char?)null;
        }

        private static char? GetAccessor(ConstructorInfo constructorInfo)
        {
            return constructorInfo.IsPublic ? '+' : constructorInfo.IsFamily ? '#' : constructorInfo.IsPrivate ? '-' : (char?)null;
        }

        private static char? GetAccessor(MethodInfo methodInfo)
        {
            return methodInfo.IsPublic ? '+' : methodInfo.IsFamily ? '#' : methodInfo.IsPrivate ? '-' : (char?)null;
        }

        private static bool IsCompilerGenerated(MethodInfo method)
        {
            return method.GetCustomAttribute<CompilerGeneratedAttribute>() != null;
        }
    }
}